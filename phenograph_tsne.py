#! /usr/bin/python3.5
import sys
import numpy as np
import matplotlib as mpl
mpl.use('Agg')
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
import phenograph

# This program is part of the cluster_diffex pipeline.  It uses the Phenograph program from Jacob Levine and Dana Pe'er
# to compute a k-nearest neighbors graph and identify clusters in single cell RNA-Seq data.  We specifically implement
# the Phenograph algorithm here to take the similarity matrices from our similarity_pipeline as input. This program
# also superimposes the Phenograph clusters or communities on the t-SNE visualization generated by the similarity_pipeline.


corr_INFILE = sys.argv[1] # file containing the similarity matrix
tsne_INFILE = sys.argv[2] # file containing the t-SNE coordinates (two dimensional)
matrix_INFILE = sys.argv[3] # file containing the matrix of molecular counts
pg_OUTFILE = sys.argv[4] # output file containing the cluster or community ID for each cell
pop_PREFIX = sys.argv[5] # output file prefix
tsne_PDF = sys.argv[6] # output PDF for t-SNE visualization of clusters

# Load the similarity matrix into memory.
print('Loading correlation matrix...')
corr_matrix = []
with open(corr_INFILE) as f:
	for line in f:
		llist = line.split()
		corr_matrix.append([float(pt) for pt in llist])

# Load the 2D t-SNE coordinates in to memory.
print('Loading t-SNE coordinates...')
tsne_x = []
tsne_y = []
with open(tsne_INFILE) as f:
	for line in f:
		llist = line.split()
		tsne_x.append(float(llist[0]))
		tsne_y.append(float(llist[1]))

# Run the Phenograph algorithm on the similarity matrix.
# Phenograph returns a k-nearest neighbors graph and cluster or community IDs
# for each cell.
print('Clustering with Phenograph...')
corr_matrix = np.array(corr_matrix)
communities, graph, Q = phenograph.cluster(corr_matrix)

# Write the community IDs to a file.
print('Phenograph output...')
with open(pg_OUTFILE,'w') as g:
	for cell in communities:
		g.write('%(cell)d\n' % vars())

print('t-SNE PDF output...')
tsne_x = np.array(tsne_x)
tsne_y = np.array(tsne_y)
xmx = max(abs(tsne_x))
ymx = max(abs(tsne_y))
axis_mx = max((xmx,ymx))*1.1

x = len(set(communities))

# Plot t-SNE coordinates color-coded by cluster ID
with PdfPages(tsne_PDF) as pdf:
	plt.scatter(tsne_x,tsne_y,c=communities,s=10,lw=0,edgecolor='none',cmap='nipy_spectral')
	plt.xlabel('t-SNE Axis 1')
	plt.ylabel('t-SNE Axis 2')
	plt.xlim([-axis_mx,axis_mx])
	plt.ylim([-axis_mx,axis_mx])
	ax = plt.gca()
	ax.set_aspect('equal')
	pdf.savefig()
	plt.close()
	for community in range(x): # Plot t-SNE coordinates with coloring of each individual cluster
		comm = [1 if pt==community else 0 for pt in communities]
		plt.scatter(tsne_x,tsne_y,c=comm,s=10,lw=0,edgecolor='none',cmap='cool')
		plt.xlabel('t-SNE Axis 1')
		plt.ylabel('t-SNE Axis 2')
		plt.title('%(community)d' % vars())
		plt.xlim([-axis_mx,axis_mx])
		plt.ylim([-axis_mx,axis_mx])
		ax = plt.gca()
		ax.set_aspect('equal')
		pdf.savefig()
		plt.close()

# Load the matrix of molecular counts into memory.
print('Loading raw counts...')
Ncells = len(communities)
xargs = communities.argsort()
gids = []
genes = []
matrix = []
with open(matrix_INFILE) as f:
	for line in f:
		llist = line.split()
		gids.append(llist[0])
		genes.append(llist[1])
		matrix.append(np.array([int(llist[i]) for i in range(2,Ncells+2)])[xargs])

# For each cluster or community, output a matrix of molecular counts and write to a file.
print('Raw community output...')
clist = list(communities)
Ncomms = [clist.count(i) for i in range(-1,max(communities)+1)] # get the number of cells in each community
Ngenes = len(gids)
x = min(communities)
st = 0
sp = Ncomms[0]
print(Ncomms)
for i in range(len(Ncomms)):
	if Ncomms[i] > 0:
		pop_OUTFILE = pop_PREFIX+'_'+str(x)+'.matrix.txt'
		with open(pop_OUTFILE,'w') as g: # generate a header with the community ID
			header = 'gene'+'\t'+'\t'.join(['comm0'+str(x) if len(str(x))==1 else 'comm'+str(x) for pt in range(Ncomms[i])])+'\n'
			g.write(header)
			for j in range(Ngenes):
				gid = gids[j]
				cts = list(matrix[j][st:sp])
				stcts = '\t'.join([str(ct) for ct in cts])
				sttot = gid+'\t'+stcts+'\n'
				g.write(sttot)
		x+=1
	if i < len(Ncomms)-1:
		st += Ncomms[i]
		sp += Ncomms[i+1]
	












